'use strict';

exports.__esModule = true;
exports.getTypeScriptTestListFromCode = exports.getTypeScriptTestList = undefined;

var _typescript = require('typescript');

var _typescript2 = _interopRequireDefault(_typescript);

var _lodash = require('lodash');

var _compiler = require('./compiler');

var _compiler2 = _interopRequireDefault(_compiler);

var _testFileParserBase = require('../../test-file-parser-base');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function replaceComments(code) {
    return code.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, match => {
        const lastSymbol = match.indexOf('\n') > -1 ? '\n' : ' ';

        return (0, _lodash.repeat)(' ', match.length + lastSymbol);
    });
}

class TypeScriptTestFileParser extends _testFileParserBase.TestFileParserBase {
    constructor() {
        super(_typescript2.default.SyntaxKind);
    }

    getComputedNameString({ pos, end }) {
        const templatePos = this.getLocationByOffsets(pos, end);

        return _testFileParserBase.TestFileParserBase.formatComputedName(templatePos.loc.start.line);
    }

    getTokenType(token) {
        return token.kind;
    }

    getCalleeToken(token) {
        return token.expression;
    }

    getMemberFnName(token) {
        return token.expression.name.text;
    }

    getKeyValue(prop) {
        const name = prop.name,
              initializer = prop.initializer;


        return {
            key: name.text,
            value: this.getStringValue(initializer)
        };
    }

    getFixedStartOffset(start) {
        let fixedStartOffset = start;

        while (/\s/.test(this.codeWithoutComments[fixedStartOffset])) ++fixedStartOffset;

        return fixedStartOffset;
    }

    getLocationByOffsets(start, end) {
        const fixedStart = this.getFixedStartOffset(start);
        const codeArr = this.codeArr;
        const loc = { start: null, end: null };

        let line = codeArr[0];
        let startTmp = fixedStart;
        let endTmp = end;

        for (let lineNumber = 1; lineNumber <= codeArr.length; ++lineNumber, line = codeArr[lineNumber - 1]) {
            startTmp -= line.length + 1;
            endTmp -= line.length + 1;

            if (startTmp < 0 && !loc.start) loc.start = { line: lineNumber, column: line.length + startTmp + 1 };

            if (endTmp <= 0 || lineNumber === codeArr.length - 1) {
                loc.end = { line: lineNumber, column: line.length + endTmp + 1 };

                break;
            }
        }

        return { loc, start: fixedStart, end };
    }

    getRValue(token) {
        return token.declarationList.declarations[0].initializer;
    }

    getStringValue(token) {
        const stringTypes = [this.tokenType.StringLiteral, this.tokenType.TemplateExpression];

        if (stringTypes.indexOf(token.kind) > -1 || token.text && token.kind !== this.tokenType.NumericLiteral) return this.formatFnArg(token);

        return null;
    }

    isAsyncFn(token) {
        const isGeneratorFn = !!token.asteriskToken;
        const isAsyncFn = token.modifiers && token.modifiers.some(modifier => modifier.kind === this.tokenType.AsyncKeyword);

        return isGeneratorFn || isAsyncFn;
    }

    getFunctionBody(token) {
        return token.body.statements;
    }

    formatFnData(name, value, token, meta = [{}]) {
        const loc = this.getLocationByOffsets(token.pos, token.end);

        return {
            fnName: name,
            value: value,
            loc: loc.loc,
            start: loc.start,
            end: loc.end,
            meta: (0, _lodash.merge)({}, ...meta)
        };
    }

    analyzeMemberExp(token) {
        let exp = token;
        const tokenType = this.tokenType;
        const callStack = [exp];

        while (exp.kind !== this.tokenType.Identifier) {
            exp = exp.expression || exp.tag;

            callStack.push(exp);
        }

        const meta = this.getMetaInfo(callStack.slice());

        if (exp && this.isApiFn(exp.text)) {
            let parentExp = callStack.pop();

            while (parentExp) {
                if (parentExp.kind === tokenType.CallExpression && parentExp.expression) {
                    const calleeType = parentExp.expression.kind;
                    const calleeMemberFn = calleeType === tokenType.PropertyAccessExpression && parentExp.expression.name.text;

                    if (this.checkExpDefineTargetName(calleeType, calleeMemberFn)) return this.formatFnData(exp.text, this.formatFnArg(parentExp.arguments[0]), token, meta);
                }

                if (parentExp.kind === tokenType.TaggedTemplateExpression && parentExp.tag) {
                    const tagType = parentExp.tag.kind;
                    const tagMemberFn = tagType === tokenType.PropertyAccessExpression && parentExp.tag.name.text;

                    if (this.checkExpDefineTargetName(tagType, tagMemberFn)) return this.formatFnData(exp.text, this.formatFnArg(parentExp), token, meta);
                }

                parentExp = callStack.pop();
            }
        }

        return null;
    }

    formatFnArg(arg) {
        if (arg.templateSpans) return this.getComputedNameString({ pos: arg.pos, end: arg.end });

        if (arg.head) return this.getComputedNameString({ pos: arg.template.pos, end: arg.template.end });

        if (arg.template) return arg.template.text || this.getComputedNameString({ pos: arg.template.pos, end: arg.template.end });

        if (arg.kind === this.tokenType.Identifier) return this.getComputedNameString({ pos: arg.pos, end: arg.end });

        if (arg.text && arg.kind !== this.tokenType.NumericLiteral) return arg.text;

        if (arg.kind === this.tokenType.TypeAssertionExpression) return this.formatFnArg(arg.expression);

        return null;
    }

    getFnCall(token) {
        if (this.isApiFn(token.expression.text)) return this.formatFnData(token.expression.text, this.formatFnArg(token.arguments[0]), token);

        return null;
    }

    getTaggedTemplateExp(token) {
        if (this.isApiFn(token.tag.text)) return this.formatFnData(token.tag.text, this.formatFnArg(token), token);

        return null;
    }

    analyzeFnCall(token) {
        const tokenType = this.tokenType;

        if (token.kind === tokenType.PropertyAccessExpression) return this.analyzeMemberExp(token);

        if (token.kind === tokenType.CallExpression) {
            const expKind = token.expression.kind;

            if (expKind === tokenType.PropertyAccessExpression || expKind === tokenType.CallExpression) return this.analyzeMemberExp(token);

            if (expKind === tokenType.ParenthesizedExpression) return this.analyzeFnCall(token.expression.expression);

            return this.getFnCall(token);
        }

        if (token.kind === tokenType.FunctionExpression || token.kind === tokenType.ArrowFunction) return this.collectTestCafeCalls(this.getFunctionBody(token));

        if (token.kind === tokenType.TaggedTemplateExpression) {
            if (token.tag.kind === tokenType.PropertyAccessExpression || token.tag.kind === tokenType.CallExpression) return this.analyzeMemberExp(token);

            return this.getTaggedTemplateExp(token);
        }

        return null;
    }

    parse(code) {
        //NOTE: TypeScript calculates start position of a token incorrectly
        //It doesn't consider spaces and comments between the last token and the current token.
        //So we replace comments with space symbols to calculate fixed position.
        //We just increment position until we meet non whitespace characters
        this.codeArr = code.split('\n');
        this.codeWithoutComments = replaceComments(code);

        const sourceFile = _typescript2.default.createSourceFile('', code, _compiler2.default._getTypescriptOptions(), true);

        return this.analyze(sourceFile.statements);
    }
}

const parser = new TypeScriptTestFileParser();

const getTypeScriptTestList = exports.getTypeScriptTestList = parser.getTestList.bind(parser);
const getTypeScriptTestListFromCode = exports.getTypeScriptTestListFromCode = parser.getTestListFromCode.bind(parser);
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9jb21waWxlci90ZXN0LWZpbGUvZm9ybWF0cy90eXBlc2NyaXB0L2dldC10ZXN0LWxpc3QuanMiXSwibmFtZXMiOlsicmVwbGFjZUNvbW1lbnRzIiwiY29kZSIsInJlcGxhY2UiLCJtYXRjaCIsImxhc3RTeW1ib2wiLCJpbmRleE9mIiwibGVuZ3RoIiwiVHlwZVNjcmlwdFRlc3RGaWxlUGFyc2VyIiwiY29uc3RydWN0b3IiLCJTeW50YXhLaW5kIiwiZ2V0Q29tcHV0ZWROYW1lU3RyaW5nIiwicG9zIiwiZW5kIiwidGVtcGxhdGVQb3MiLCJnZXRMb2NhdGlvbkJ5T2Zmc2V0cyIsImZvcm1hdENvbXB1dGVkTmFtZSIsImxvYyIsInN0YXJ0IiwibGluZSIsImdldFRva2VuVHlwZSIsInRva2VuIiwia2luZCIsImdldENhbGxlZVRva2VuIiwiZXhwcmVzc2lvbiIsImdldE1lbWJlckZuTmFtZSIsIm5hbWUiLCJ0ZXh0IiwiZ2V0S2V5VmFsdWUiLCJwcm9wIiwiaW5pdGlhbGl6ZXIiLCJrZXkiLCJ2YWx1ZSIsImdldFN0cmluZ1ZhbHVlIiwiZ2V0Rml4ZWRTdGFydE9mZnNldCIsImZpeGVkU3RhcnRPZmZzZXQiLCJ0ZXN0IiwiY29kZVdpdGhvdXRDb21tZW50cyIsImZpeGVkU3RhcnQiLCJjb2RlQXJyIiwic3RhcnRUbXAiLCJlbmRUbXAiLCJsaW5lTnVtYmVyIiwiY29sdW1uIiwiZ2V0UlZhbHVlIiwiZGVjbGFyYXRpb25MaXN0IiwiZGVjbGFyYXRpb25zIiwic3RyaW5nVHlwZXMiLCJ0b2tlblR5cGUiLCJTdHJpbmdMaXRlcmFsIiwiVGVtcGxhdGVFeHByZXNzaW9uIiwiTnVtZXJpY0xpdGVyYWwiLCJmb3JtYXRGbkFyZyIsImlzQXN5bmNGbiIsImlzR2VuZXJhdG9yRm4iLCJhc3Rlcmlza1Rva2VuIiwibW9kaWZpZXJzIiwic29tZSIsIm1vZGlmaWVyIiwiQXN5bmNLZXl3b3JkIiwiZ2V0RnVuY3Rpb25Cb2R5IiwiYm9keSIsInN0YXRlbWVudHMiLCJmb3JtYXRGbkRhdGEiLCJtZXRhIiwiZm5OYW1lIiwiYW5hbHl6ZU1lbWJlckV4cCIsImV4cCIsImNhbGxTdGFjayIsIklkZW50aWZpZXIiLCJ0YWciLCJwdXNoIiwiZ2V0TWV0YUluZm8iLCJzbGljZSIsImlzQXBpRm4iLCJwYXJlbnRFeHAiLCJwb3AiLCJDYWxsRXhwcmVzc2lvbiIsImNhbGxlZVR5cGUiLCJjYWxsZWVNZW1iZXJGbiIsIlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbiIsImNoZWNrRXhwRGVmaW5lVGFyZ2V0TmFtZSIsImFyZ3VtZW50cyIsIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiIsInRhZ1R5cGUiLCJ0YWdNZW1iZXJGbiIsImFyZyIsInRlbXBsYXRlU3BhbnMiLCJoZWFkIiwidGVtcGxhdGUiLCJUeXBlQXNzZXJ0aW9uRXhwcmVzc2lvbiIsImdldEZuQ2FsbCIsImdldFRhZ2dlZFRlbXBsYXRlRXhwIiwiYW5hbHl6ZUZuQ2FsbCIsImV4cEtpbmQiLCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiIsIkZ1bmN0aW9uRXhwcmVzc2lvbiIsIkFycm93RnVuY3Rpb24iLCJjb2xsZWN0VGVzdENhZmVDYWxscyIsInBhcnNlIiwic3BsaXQiLCJzb3VyY2VGaWxlIiwiY3JlYXRlU291cmNlRmlsZSIsIl9nZXRUeXBlc2NyaXB0T3B0aW9ucyIsImFuYWx5emUiLCJwYXJzZXIiLCJnZXRUeXBlU2NyaXB0VGVzdExpc3QiLCJnZXRUZXN0TGlzdCIsImJpbmQiLCJnZXRUeXBlU2NyaXB0VGVzdExpc3RGcm9tQ29kZSIsImdldFRlc3RMaXN0RnJvbUNvZGUiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBRUEsU0FBU0EsZUFBVCxDQUEwQkMsSUFBMUIsRUFBZ0M7QUFDNUIsV0FBT0EsS0FBS0MsT0FBTCxDQUFhLHNDQUFiLEVBQXFEQyxTQUFTO0FBQ2pFLGNBQU1DLGFBQWFELE1BQU1FLE9BQU4sQ0FBYyxJQUFkLElBQXNCLENBQUMsQ0FBdkIsR0FBMkIsSUFBM0IsR0FBa0MsR0FBckQ7O0FBRUEsZUFBTyxvQkFBTyxHQUFQLEVBQVlGLE1BQU1HLE1BQU4sR0FBZUYsVUFBM0IsQ0FBUDtBQUNILEtBSk0sQ0FBUDtBQUtIOztBQUVELE1BQU1HLHdCQUFOLGdEQUEwRDtBQUN0REMsa0JBQWU7QUFDWCxjQUFNLHFCQUFHQyxVQUFUO0FBQ0g7O0FBRURDLDBCQUF1QixFQUFFQyxHQUFGLEVBQU9DLEdBQVAsRUFBdkIsRUFBcUM7QUFDakMsY0FBTUMsY0FBYyxLQUFLQyxvQkFBTCxDQUEwQkgsR0FBMUIsRUFBK0JDLEdBQS9CLENBQXBCOztBQUVBLGVBQU8sdUNBQW1CRyxrQkFBbkIsQ0FBc0NGLFlBQVlHLEdBQVosQ0FBZ0JDLEtBQWhCLENBQXNCQyxJQUE1RCxDQUFQO0FBQ0g7O0FBRURDLGlCQUFjQyxLQUFkLEVBQXFCO0FBQ2pCLGVBQU9BLE1BQU1DLElBQWI7QUFDSDs7QUFFREMsbUJBQWdCRixLQUFoQixFQUF1QjtBQUNuQixlQUFPQSxNQUFNRyxVQUFiO0FBQ0g7O0FBRURDLG9CQUFpQkosS0FBakIsRUFBd0I7QUFDcEIsZUFBT0EsTUFBTUcsVUFBTixDQUFpQkUsSUFBakIsQ0FBc0JDLElBQTdCO0FBQ0g7O0FBRURDLGdCQUFhQyxJQUFiLEVBQW1CO0FBQUEsY0FDUEgsSUFETyxHQUNlRyxJQURmLENBQ1BILElBRE87QUFBQSxjQUNESSxXQURDLEdBQ2VELElBRGYsQ0FDREMsV0FEQzs7O0FBR2YsZUFBTztBQUNIQyxpQkFBT0wsS0FBS0MsSUFEVDtBQUVISyxtQkFBTyxLQUFLQyxjQUFMLENBQW9CSCxXQUFwQjtBQUZKLFNBQVA7QUFJSDs7QUFFREksd0JBQXFCaEIsS0FBckIsRUFBNEI7QUFDeEIsWUFBSWlCLG1CQUFtQmpCLEtBQXZCOztBQUVBLGVBQU8sS0FBS2tCLElBQUwsQ0FBVSxLQUFLQyxtQkFBTCxDQUF5QkYsZ0JBQXpCLENBQVYsQ0FBUCxFQUNJLEVBQUVBLGdCQUFGOztBQUVKLGVBQU9BLGdCQUFQO0FBQ0g7O0FBRURwQix5QkFBc0JHLEtBQXRCLEVBQTZCTCxHQUE3QixFQUFrQztBQUM5QixjQUFNeUIsYUFBYSxLQUFLSixtQkFBTCxDQUF5QmhCLEtBQXpCLENBQW5CO0FBQ0EsY0FBTXFCLFVBQWEsS0FBS0EsT0FBeEI7QUFDQSxjQUFNdEIsTUFBYSxFQUFFQyxPQUFPLElBQVQsRUFBZUwsS0FBSyxJQUFwQixFQUFuQjs7QUFFQSxZQUFJTSxPQUFXb0IsUUFBUSxDQUFSLENBQWY7QUFDQSxZQUFJQyxXQUFXRixVQUFmO0FBQ0EsWUFBSUcsU0FBVzVCLEdBQWY7O0FBRUEsYUFBSyxJQUFJNkIsYUFBYSxDQUF0QixFQUF5QkEsY0FBY0gsUUFBUWhDLE1BQS9DLEVBQXVELEVBQUVtQyxVQUFGLEVBQWN2QixPQUFPb0IsUUFBUUcsYUFBYSxDQUFyQixDQUE1RSxFQUFxRztBQUNqR0Ysd0JBQVlyQixLQUFLWixNQUFMLEdBQWMsQ0FBMUI7QUFDQWtDLHNCQUFVdEIsS0FBS1osTUFBTCxHQUFjLENBQXhCOztBQUVBLGdCQUFJaUMsV0FBVyxDQUFYLElBQWdCLENBQUN2QixJQUFJQyxLQUF6QixFQUNJRCxJQUFJQyxLQUFKLEdBQVksRUFBRUMsTUFBTXVCLFVBQVIsRUFBb0JDLFFBQVF4QixLQUFLWixNQUFMLEdBQWNpQyxRQUFkLEdBQXlCLENBQXJELEVBQVo7O0FBRUosZ0JBQUlDLFVBQVUsQ0FBVixJQUFlQyxlQUFlSCxRQUFRaEMsTUFBUixHQUFpQixDQUFuRCxFQUFzRDtBQUNsRFUsb0JBQUlKLEdBQUosR0FBVSxFQUFFTSxNQUFNdUIsVUFBUixFQUFvQkMsUUFBUXhCLEtBQUtaLE1BQUwsR0FBY2tDLE1BQWQsR0FBdUIsQ0FBbkQsRUFBVjs7QUFFQTtBQUNIO0FBQ0o7O0FBRUQsZUFBTyxFQUFFeEIsR0FBRixFQUFPQyxPQUFPb0IsVUFBZCxFQUEwQnpCLEdBQTFCLEVBQVA7QUFDSDs7QUFFRCtCLGNBQVd2QixLQUFYLEVBQWtCO0FBQ2QsZUFBT0EsTUFBTXdCLGVBQU4sQ0FBc0JDLFlBQXRCLENBQW1DLENBQW5DLEVBQXNDaEIsV0FBN0M7QUFDSDs7QUFFREcsbUJBQWdCWixLQUFoQixFQUF1QjtBQUNuQixjQUFNMEIsY0FBYyxDQUFDLEtBQUtDLFNBQUwsQ0FBZUMsYUFBaEIsRUFBK0IsS0FBS0QsU0FBTCxDQUFlRSxrQkFBOUMsQ0FBcEI7O0FBRUEsWUFBSUgsWUFBWXpDLE9BQVosQ0FBb0JlLE1BQU1DLElBQTFCLElBQWtDLENBQUMsQ0FBbkMsSUFBd0NELE1BQU1NLElBQU4sSUFBY04sTUFBTUMsSUFBTixLQUFlLEtBQUswQixTQUFMLENBQWVHLGNBQXhGLEVBQ0ksT0FBTyxLQUFLQyxXQUFMLENBQWlCL0IsS0FBakIsQ0FBUDs7QUFFSixlQUFPLElBQVA7QUFDSDs7QUFFRGdDLGNBQVdoQyxLQUFYLEVBQWtCO0FBQ2QsY0FBTWlDLGdCQUFnQixDQUFDLENBQUNqQyxNQUFNa0MsYUFBOUI7QUFDQSxjQUFNRixZQUFnQmhDLE1BQU1tQyxTQUFOLElBQ0FuQyxNQUFNbUMsU0FBTixDQUFnQkMsSUFBaEIsQ0FBcUJDLFlBQVlBLFNBQVNwQyxJQUFULEtBQWtCLEtBQUswQixTQUFMLENBQWVXLFlBQWxFLENBRHRCOztBQUdBLGVBQU9MLGlCQUFpQkQsU0FBeEI7QUFDSDs7QUFFRE8sb0JBQWlCdkMsS0FBakIsRUFBd0I7QUFDcEIsZUFBT0EsTUFBTXdDLElBQU4sQ0FBV0MsVUFBbEI7QUFDSDs7QUFFREMsaUJBQWNyQyxJQUFkLEVBQW9CTSxLQUFwQixFQUEyQlgsS0FBM0IsRUFBa0MyQyxPQUFPLENBQUMsRUFBRCxDQUF6QyxFQUErQztBQUMzQyxjQUFNL0MsTUFBTSxLQUFLRixvQkFBTCxDQUEwQk0sTUFBTVQsR0FBaEMsRUFBcUNTLE1BQU1SLEdBQTNDLENBQVo7O0FBRUEsZUFBTztBQUNIb0Qsb0JBQVF2QyxJQURMO0FBRUhNLG1CQUFRQSxLQUZMO0FBR0hmLGlCQUFRQSxJQUFJQSxHQUhUO0FBSUhDLG1CQUFRRCxJQUFJQyxLQUpUO0FBS0hMLGlCQUFRSSxJQUFJSixHQUxUO0FBTUhtRCxrQkFBUSxtQkFBTSxFQUFOLEVBQVUsR0FBR0EsSUFBYjtBQU5MLFNBQVA7QUFRSDs7QUFFREUscUJBQWtCN0MsS0FBbEIsRUFBeUI7QUFDckIsWUFBSThDLE1BQWM5QyxLQUFsQjtBQUNBLGNBQU0yQixZQUFZLEtBQUtBLFNBQXZCO0FBQ0EsY0FBTW9CLFlBQVksQ0FBQ0QsR0FBRCxDQUFsQjs7QUFFQSxlQUFPQSxJQUFJN0MsSUFBSixLQUFhLEtBQUswQixTQUFMLENBQWVxQixVQUFuQyxFQUErQztBQUMzQ0Ysa0JBQU1BLElBQUkzQyxVQUFKLElBQWtCMkMsSUFBSUcsR0FBNUI7O0FBRUFGLHNCQUFVRyxJQUFWLENBQWVKLEdBQWY7QUFDSDs7QUFFRCxjQUFNSCxPQUFPLEtBQUtRLFdBQUwsQ0FBaUJKLFVBQVVLLEtBQVYsRUFBakIsQ0FBYjs7QUFFQSxZQUFJTixPQUFPLEtBQUtPLE9BQUwsQ0FBYVAsSUFBSXhDLElBQWpCLENBQVgsRUFBbUM7QUFDL0IsZ0JBQUlnRCxZQUFZUCxVQUFVUSxHQUFWLEVBQWhCOztBQUVBLG1CQUFPRCxTQUFQLEVBQWtCO0FBQ2Qsb0JBQUlBLFVBQVVyRCxJQUFWLEtBQW1CMEIsVUFBVTZCLGNBQTdCLElBQStDRixVQUFVbkQsVUFBN0QsRUFBeUU7QUFDckUsMEJBQU1zRCxhQUFpQkgsVUFBVW5ELFVBQVYsQ0FBcUJGLElBQTVDO0FBQ0EsMEJBQU15RCxpQkFBaUJELGVBQWU5QixVQUFVZ0Msd0JBQXpCLElBQ0FMLFVBQVVuRCxVQUFWLENBQXFCRSxJQUFyQixDQUEwQkMsSUFEakQ7O0FBR0Esd0JBQUksS0FBS3NELHdCQUFMLENBQThCSCxVQUE5QixFQUEwQ0MsY0FBMUMsQ0FBSixFQUNJLE9BQU8sS0FBS2hCLFlBQUwsQ0FBa0JJLElBQUl4QyxJQUF0QixFQUE0QixLQUFLeUIsV0FBTCxDQUFpQnVCLFVBQVVPLFNBQVYsQ0FBb0IsQ0FBcEIsQ0FBakIsQ0FBNUIsRUFBc0U3RCxLQUF0RSxFQUE2RTJDLElBQTdFLENBQVA7QUFDUDs7QUFFRCxvQkFBSVcsVUFBVXJELElBQVYsS0FBbUIwQixVQUFVbUMsd0JBQTdCLElBQXlEUixVQUFVTCxHQUF2RSxFQUE0RTtBQUN4RSwwQkFBTWMsVUFBY1QsVUFBVUwsR0FBVixDQUFjaEQsSUFBbEM7QUFDQSwwQkFBTStELGNBQWNELFlBQVlwQyxVQUFVZ0Msd0JBQXRCLElBQWtETCxVQUFVTCxHQUFWLENBQWM1QyxJQUFkLENBQW1CQyxJQUF6Rjs7QUFFQSx3QkFBSSxLQUFLc0Qsd0JBQUwsQ0FBOEJHLE9BQTlCLEVBQXVDQyxXQUF2QyxDQUFKLEVBQ0ksT0FBTyxLQUFLdEIsWUFBTCxDQUFrQkksSUFBSXhDLElBQXRCLEVBQTRCLEtBQUt5QixXQUFMLENBQWlCdUIsU0FBakIsQ0FBNUIsRUFBeUR0RCxLQUF6RCxFQUFnRTJDLElBQWhFLENBQVA7QUFDUDs7QUFFRFcsNEJBQVlQLFVBQVVRLEdBQVYsRUFBWjtBQUNIO0FBQ0o7O0FBRUQsZUFBTyxJQUFQO0FBQ0g7O0FBRUR4QixnQkFBYWtDLEdBQWIsRUFBa0I7QUFDZCxZQUFJQSxJQUFJQyxhQUFSLEVBQ0ksT0FBTyxLQUFLNUUscUJBQUwsQ0FBMkIsRUFBRUMsS0FBSzBFLElBQUkxRSxHQUFYLEVBQWdCQyxLQUFLeUUsSUFBSXpFLEdBQXpCLEVBQTNCLENBQVA7O0FBRUosWUFBSXlFLElBQUlFLElBQVIsRUFDSSxPQUFPLEtBQUs3RSxxQkFBTCxDQUEyQixFQUFFQyxLQUFLMEUsSUFBSUcsUUFBSixDQUFhN0UsR0FBcEIsRUFBeUJDLEtBQUt5RSxJQUFJRyxRQUFKLENBQWE1RSxHQUEzQyxFQUEzQixDQUFQOztBQUVKLFlBQUl5RSxJQUFJRyxRQUFSLEVBQ0ksT0FBT0gsSUFBSUcsUUFBSixDQUFhOUQsSUFBYixJQUFxQixLQUFLaEIscUJBQUwsQ0FBMkIsRUFBRUMsS0FBSzBFLElBQUlHLFFBQUosQ0FBYTdFLEdBQXBCLEVBQXlCQyxLQUFLeUUsSUFBSUcsUUFBSixDQUFhNUUsR0FBM0MsRUFBM0IsQ0FBNUI7O0FBRUosWUFBSXlFLElBQUloRSxJQUFKLEtBQWEsS0FBSzBCLFNBQUwsQ0FBZXFCLFVBQWhDLEVBQ0ksT0FBTyxLQUFLMUQscUJBQUwsQ0FBMkIsRUFBRUMsS0FBSzBFLElBQUkxRSxHQUFYLEVBQWdCQyxLQUFLeUUsSUFBSXpFLEdBQXpCLEVBQTNCLENBQVA7O0FBRUosWUFBSXlFLElBQUkzRCxJQUFKLElBQVkyRCxJQUFJaEUsSUFBSixLQUFhLEtBQUswQixTQUFMLENBQWVHLGNBQTVDLEVBQ0ksT0FBT21DLElBQUkzRCxJQUFYOztBQUVKLFlBQUkyRCxJQUFJaEUsSUFBSixLQUFhLEtBQUswQixTQUFMLENBQWUwQyx1QkFBaEMsRUFDSSxPQUFPLEtBQUt0QyxXQUFMLENBQWlCa0MsSUFBSTlELFVBQXJCLENBQVA7O0FBRUosZUFBTyxJQUFQO0FBQ0g7O0FBRURtRSxjQUFXdEUsS0FBWCxFQUFrQjtBQUNkLFlBQUksS0FBS3FELE9BQUwsQ0FBYXJELE1BQU1HLFVBQU4sQ0FBaUJHLElBQTlCLENBQUosRUFDSSxPQUFPLEtBQUtvQyxZQUFMLENBQWtCMUMsTUFBTUcsVUFBTixDQUFpQkcsSUFBbkMsRUFBeUMsS0FBS3lCLFdBQUwsQ0FBaUIvQixNQUFNNkQsU0FBTixDQUFnQixDQUFoQixDQUFqQixDQUF6QyxFQUErRTdELEtBQS9FLENBQVA7O0FBRUosZUFBTyxJQUFQO0FBQ0g7O0FBRUR1RSx5QkFBc0J2RSxLQUF0QixFQUE2QjtBQUN6QixZQUFJLEtBQUtxRCxPQUFMLENBQWFyRCxNQUFNaUQsR0FBTixDQUFVM0MsSUFBdkIsQ0FBSixFQUNJLE9BQU8sS0FBS29DLFlBQUwsQ0FBa0IxQyxNQUFNaUQsR0FBTixDQUFVM0MsSUFBNUIsRUFBa0MsS0FBS3lCLFdBQUwsQ0FBaUIvQixLQUFqQixDQUFsQyxFQUEyREEsS0FBM0QsQ0FBUDs7QUFFSixlQUFPLElBQVA7QUFDSDs7QUFFRHdFLGtCQUFleEUsS0FBZixFQUFzQjtBQUNsQixjQUFNMkIsWUFBWSxLQUFLQSxTQUF2Qjs7QUFFQSxZQUFJM0IsTUFBTUMsSUFBTixLQUFlMEIsVUFBVWdDLHdCQUE3QixFQUNJLE9BQU8sS0FBS2QsZ0JBQUwsQ0FBc0I3QyxLQUF0QixDQUFQOztBQUVKLFlBQUlBLE1BQU1DLElBQU4sS0FBZTBCLFVBQVU2QixjQUE3QixFQUE2QztBQUN6QyxrQkFBTWlCLFVBQVV6RSxNQUFNRyxVQUFOLENBQWlCRixJQUFqQzs7QUFFQSxnQkFBSXdFLFlBQVk5QyxVQUFVZ0Msd0JBQXRCLElBQWtEYyxZQUFZOUMsVUFBVTZCLGNBQTVFLEVBQ0ksT0FBTyxLQUFLWCxnQkFBTCxDQUFzQjdDLEtBQXRCLENBQVA7O0FBRUosZ0JBQUl5RSxZQUFZOUMsVUFBVStDLHVCQUExQixFQUNJLE9BQU8sS0FBS0YsYUFBTCxDQUFtQnhFLE1BQU1HLFVBQU4sQ0FBaUJBLFVBQXBDLENBQVA7O0FBRUosbUJBQU8sS0FBS21FLFNBQUwsQ0FBZXRFLEtBQWYsQ0FBUDtBQUNIOztBQUVELFlBQUlBLE1BQU1DLElBQU4sS0FBZTBCLFVBQVVnRCxrQkFBekIsSUFBK0MzRSxNQUFNQyxJQUFOLEtBQWUwQixVQUFVaUQsYUFBNUUsRUFDSSxPQUFPLEtBQUtDLG9CQUFMLENBQTBCLEtBQUt0QyxlQUFMLENBQXFCdkMsS0FBckIsQ0FBMUIsQ0FBUDs7QUFFSixZQUFJQSxNQUFNQyxJQUFOLEtBQWUwQixVQUFVbUMsd0JBQTdCLEVBQXVEO0FBQ25ELGdCQUFJOUQsTUFBTWlELEdBQU4sQ0FBVWhELElBQVYsS0FBbUIwQixVQUFVZ0Msd0JBQTdCLElBQXlEM0QsTUFBTWlELEdBQU4sQ0FBVWhELElBQVYsS0FBbUIwQixVQUFVNkIsY0FBMUYsRUFDSSxPQUFPLEtBQUtYLGdCQUFMLENBQXNCN0MsS0FBdEIsQ0FBUDs7QUFFSixtQkFBTyxLQUFLdUUsb0JBQUwsQ0FBMEJ2RSxLQUExQixDQUFQO0FBQ0g7O0FBRUQsZUFBTyxJQUFQO0FBQ0g7O0FBRUQ4RSxVQUFPakcsSUFBUCxFQUFhO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLcUMsT0FBTCxHQUEyQnJDLEtBQUtrRyxLQUFMLENBQVcsSUFBWCxDQUEzQjtBQUNBLGFBQUsvRCxtQkFBTCxHQUEyQnBDLGdCQUFnQkMsSUFBaEIsQ0FBM0I7O0FBRUEsY0FBTW1HLGFBQWEscUJBQUdDLGdCQUFILENBQW9CLEVBQXBCLEVBQXdCcEcsSUFBeEIsRUFBOEIsbUJBQTJCcUcscUJBQTNCLEVBQTlCLEVBQWtGLElBQWxGLENBQW5COztBQUVBLGVBQU8sS0FBS0MsT0FBTCxDQUFhSCxXQUFXdkMsVUFBeEIsQ0FBUDtBQUNIO0FBaE9xRDs7QUFtTzFELE1BQU0yQyxTQUFTLElBQUlqRyx3QkFBSixFQUFmOztBQUVPLE1BQU1rRyx3REFBZ0NELE9BQU9FLFdBQVAsQ0FBbUJDLElBQW5CLENBQXdCSCxNQUF4QixDQUF0QztBQUNBLE1BQU1JLHdFQUFnQ0osT0FBT0ssbUJBQVAsQ0FBMkJGLElBQTNCLENBQWdDSCxNQUFoQyxDQUF0QyIsImZpbGUiOiJjb21waWxlci90ZXN0LWZpbGUvZm9ybWF0cy90eXBlc2NyaXB0L2dldC10ZXN0LWxpc3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5pbXBvcnQgeyByZXBlYXQsIG1lcmdlIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlciBmcm9tICcuL2NvbXBpbGVyJztcbmltcG9ydCB7IFRlc3RGaWxlUGFyc2VyQmFzZSB9IGZyb20gJy4uLy4uL3Rlc3QtZmlsZS1wYXJzZXItYmFzZSc7XG5cbmZ1bmN0aW9uIHJlcGxhY2VDb21tZW50cyAoY29kZSkge1xuICAgIHJldHVybiBjb2RlLnJlcGxhY2UoL1xcL1xcKltcXHNcXFNdKj9cXCpcXC98KFteXFxcXDpdfF4pXFwvXFwvLiokL2dtLCBtYXRjaCA9PiB7XG4gICAgICAgIGNvbnN0IGxhc3RTeW1ib2wgPSBtYXRjaC5pbmRleE9mKCdcXG4nKSA+IC0xID8gJ1xcbicgOiAnICc7XG5cbiAgICAgICAgcmV0dXJuIHJlcGVhdCgnICcsIG1hdGNoLmxlbmd0aCArIGxhc3RTeW1ib2wpO1xuICAgIH0pO1xufVxuXG5jbGFzcyBUeXBlU2NyaXB0VGVzdEZpbGVQYXJzZXIgZXh0ZW5kcyBUZXN0RmlsZVBhcnNlckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgICAgc3VwZXIodHMuU3ludGF4S2luZCk7XG4gICAgfVxuXG4gICAgZ2V0Q29tcHV0ZWROYW1lU3RyaW5nICh7IHBvcywgZW5kIH0pIHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGVQb3MgPSB0aGlzLmdldExvY2F0aW9uQnlPZmZzZXRzKHBvcywgZW5kKTtcblxuICAgICAgICByZXR1cm4gVGVzdEZpbGVQYXJzZXJCYXNlLmZvcm1hdENvbXB1dGVkTmFtZSh0ZW1wbGF0ZVBvcy5sb2Muc3RhcnQubGluZSk7XG4gICAgfVxuXG4gICAgZ2V0VG9rZW5UeXBlICh0b2tlbikge1xuICAgICAgICByZXR1cm4gdG9rZW4ua2luZDtcbiAgICB9XG5cbiAgICBnZXRDYWxsZWVUb2tlbiAodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRva2VuLmV4cHJlc3Npb247XG4gICAgfVxuXG4gICAgZ2V0TWVtYmVyRm5OYW1lICh0b2tlbikge1xuICAgICAgICByZXR1cm4gdG9rZW4uZXhwcmVzc2lvbi5uYW1lLnRleHQ7XG4gICAgfVxuXG4gICAgZ2V0S2V5VmFsdWUgKHByb3ApIHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBpbml0aWFsaXplciB9ID0gcHJvcDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiAgIG5hbWUudGV4dCxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmdldFN0cmluZ1ZhbHVlKGluaXRpYWxpemVyKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGdldEZpeGVkU3RhcnRPZmZzZXQgKHN0YXJ0KSB7XG4gICAgICAgIGxldCBmaXhlZFN0YXJ0T2Zmc2V0ID0gc3RhcnQ7XG5cbiAgICAgICAgd2hpbGUgKC9cXHMvLnRlc3QodGhpcy5jb2RlV2l0aG91dENvbW1lbnRzW2ZpeGVkU3RhcnRPZmZzZXRdKSlcbiAgICAgICAgICAgICsrZml4ZWRTdGFydE9mZnNldDtcblxuICAgICAgICByZXR1cm4gZml4ZWRTdGFydE9mZnNldDtcbiAgICB9XG5cbiAgICBnZXRMb2NhdGlvbkJ5T2Zmc2V0cyAoc3RhcnQsIGVuZCkge1xuICAgICAgICBjb25zdCBmaXhlZFN0YXJ0ID0gdGhpcy5nZXRGaXhlZFN0YXJ0T2Zmc2V0KHN0YXJ0KTtcbiAgICAgICAgY29uc3QgY29kZUFyciAgICA9IHRoaXMuY29kZUFycjtcbiAgICAgICAgY29uc3QgbG9jICAgICAgICA9IHsgc3RhcnQ6IG51bGwsIGVuZDogbnVsbCB9O1xuXG4gICAgICAgIGxldCBsaW5lICAgICA9IGNvZGVBcnJbMF07XG4gICAgICAgIGxldCBzdGFydFRtcCA9IGZpeGVkU3RhcnQ7XG4gICAgICAgIGxldCBlbmRUbXAgICA9IGVuZDtcblxuICAgICAgICBmb3IgKGxldCBsaW5lTnVtYmVyID0gMTsgbGluZU51bWJlciA8PSBjb2RlQXJyLmxlbmd0aDsgKytsaW5lTnVtYmVyLCBsaW5lID0gY29kZUFycltsaW5lTnVtYmVyIC0gMV0pIHtcbiAgICAgICAgICAgIHN0YXJ0VG1wIC09IGxpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGVuZFRtcCAtPSBsaW5lLmxlbmd0aCArIDE7XG5cbiAgICAgICAgICAgIGlmIChzdGFydFRtcCA8IDAgJiYgIWxvYy5zdGFydClcbiAgICAgICAgICAgICAgICBsb2Muc3RhcnQgPSB7IGxpbmU6IGxpbmVOdW1iZXIsIGNvbHVtbjogbGluZS5sZW5ndGggKyBzdGFydFRtcCArIDEgfTtcblxuICAgICAgICAgICAgaWYgKGVuZFRtcCA8PSAwIHx8IGxpbmVOdW1iZXIgPT09IGNvZGVBcnIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7IGxpbmU6IGxpbmVOdW1iZXIsIGNvbHVtbjogbGluZS5sZW5ndGggKyBlbmRUbXAgKyAxIH07XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGxvYywgc3RhcnQ6IGZpeGVkU3RhcnQsIGVuZCB9O1xuICAgIH1cblxuICAgIGdldFJWYWx1ZSAodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRva2VuLmRlY2xhcmF0aW9uTGlzdC5kZWNsYXJhdGlvbnNbMF0uaW5pdGlhbGl6ZXI7XG4gICAgfVxuXG4gICAgZ2V0U3RyaW5nVmFsdWUgKHRva2VuKSB7XG4gICAgICAgIGNvbnN0IHN0cmluZ1R5cGVzID0gW3RoaXMudG9rZW5UeXBlLlN0cmluZ0xpdGVyYWwsIHRoaXMudG9rZW5UeXBlLlRlbXBsYXRlRXhwcmVzc2lvbl07XG5cbiAgICAgICAgaWYgKHN0cmluZ1R5cGVzLmluZGV4T2YodG9rZW4ua2luZCkgPiAtMSB8fCB0b2tlbi50ZXh0ICYmIHRva2VuLmtpbmQgIT09IHRoaXMudG9rZW5UeXBlLk51bWVyaWNMaXRlcmFsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0Rm5BcmcodG9rZW4pO1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlzQXN5bmNGbiAodG9rZW4pIHtcbiAgICAgICAgY29uc3QgaXNHZW5lcmF0b3JGbiA9ICEhdG9rZW4uYXN0ZXJpc2tUb2tlbjtcbiAgICAgICAgY29uc3QgaXNBc3luY0ZuICAgICA9IHRva2VuLm1vZGlmaWVycyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4ubW9kaWZpZXJzLnNvbWUobW9kaWZpZXIgPT4gbW9kaWZpZXIua2luZCA9PT0gdGhpcy50b2tlblR5cGUuQXN5bmNLZXl3b3JkKTtcblxuICAgICAgICByZXR1cm4gaXNHZW5lcmF0b3JGbiB8fCBpc0FzeW5jRm47XG4gICAgfVxuXG4gICAgZ2V0RnVuY3Rpb25Cb2R5ICh0b2tlbikge1xuICAgICAgICByZXR1cm4gdG9rZW4uYm9keS5zdGF0ZW1lbnRzO1xuICAgIH1cblxuICAgIGZvcm1hdEZuRGF0YSAobmFtZSwgdmFsdWUsIHRva2VuLCBtZXRhID0gW3t9XSkge1xuICAgICAgICBjb25zdCBsb2MgPSB0aGlzLmdldExvY2F0aW9uQnlPZmZzZXRzKHRva2VuLnBvcywgdG9rZW4uZW5kKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm5OYW1lOiBuYW1lLFxuICAgICAgICAgICAgdmFsdWU6ICB2YWx1ZSxcbiAgICAgICAgICAgIGxvYzogICAgbG9jLmxvYyxcbiAgICAgICAgICAgIHN0YXJ0OiAgbG9jLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiAgICBsb2MuZW5kLFxuICAgICAgICAgICAgbWV0YTogICBtZXJnZSh7fSwgLi4ubWV0YSlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhbmFseXplTWVtYmVyRXhwICh0b2tlbikge1xuICAgICAgICBsZXQgZXhwICAgICAgICAgPSB0b2tlbjtcbiAgICAgICAgY29uc3QgdG9rZW5UeXBlID0gdGhpcy50b2tlblR5cGU7XG4gICAgICAgIGNvbnN0IGNhbGxTdGFjayA9IFtleHBdO1xuXG4gICAgICAgIHdoaWxlIChleHAua2luZCAhPT0gdGhpcy50b2tlblR5cGUuSWRlbnRpZmllcikge1xuICAgICAgICAgICAgZXhwID0gZXhwLmV4cHJlc3Npb24gfHwgZXhwLnRhZztcblxuICAgICAgICAgICAgY2FsbFN0YWNrLnB1c2goZXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldE1ldGFJbmZvKGNhbGxTdGFjay5zbGljZSgpKTtcblxuICAgICAgICBpZiAoZXhwICYmIHRoaXMuaXNBcGlGbihleHAudGV4dCkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRFeHAgPSBjYWxsU3RhY2sucG9wKCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnRFeHApIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50RXhwLmtpbmQgPT09IHRva2VuVHlwZS5DYWxsRXhwcmVzc2lvbiAmJiBwYXJlbnRFeHAuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZWVUeXBlICAgICA9IHBhcmVudEV4cC5leHByZXNzaW9uLmtpbmQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlZU1lbWJlckZuID0gY2FsbGVlVHlwZSA9PT0gdG9rZW5UeXBlLlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEV4cC5leHByZXNzaW9uLm5hbWUudGV4dDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja0V4cERlZmluZVRhcmdldE5hbWUoY2FsbGVlVHlwZSwgY2FsbGVlTWVtYmVyRm4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0Rm5EYXRhKGV4cC50ZXh0LCB0aGlzLmZvcm1hdEZuQXJnKHBhcmVudEV4cC5hcmd1bWVudHNbMF0pLCB0b2tlbiwgbWV0YSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEV4cC5raW5kID09PSB0b2tlblR5cGUuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uICYmIHBhcmVudEV4cC50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFnVHlwZSAgICAgPSBwYXJlbnRFeHAudGFnLmtpbmQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhZ01lbWJlckZuID0gdGFnVHlwZSA9PT0gdG9rZW5UeXBlLlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbiAmJiBwYXJlbnRFeHAudGFnLm5hbWUudGV4dDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja0V4cERlZmluZVRhcmdldE5hbWUodGFnVHlwZSwgdGFnTWVtYmVyRm4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0Rm5EYXRhKGV4cC50ZXh0LCB0aGlzLmZvcm1hdEZuQXJnKHBhcmVudEV4cCksIHRva2VuLCBtZXRhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJlbnRFeHAgPSBjYWxsU3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmb3JtYXRGbkFyZyAoYXJnKSB7XG4gICAgICAgIGlmIChhcmcudGVtcGxhdGVTcGFucylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbXB1dGVkTmFtZVN0cmluZyh7IHBvczogYXJnLnBvcywgZW5kOiBhcmcuZW5kIH0pO1xuXG4gICAgICAgIGlmIChhcmcuaGVhZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbXB1dGVkTmFtZVN0cmluZyh7IHBvczogYXJnLnRlbXBsYXRlLnBvcywgZW5kOiBhcmcudGVtcGxhdGUuZW5kIH0pO1xuXG4gICAgICAgIGlmIChhcmcudGVtcGxhdGUpXG4gICAgICAgICAgICByZXR1cm4gYXJnLnRlbXBsYXRlLnRleHQgfHwgdGhpcy5nZXRDb21wdXRlZE5hbWVTdHJpbmcoeyBwb3M6IGFyZy50ZW1wbGF0ZS5wb3MsIGVuZDogYXJnLnRlbXBsYXRlLmVuZCB9KTtcblxuICAgICAgICBpZiAoYXJnLmtpbmQgPT09IHRoaXMudG9rZW5UeXBlLklkZW50aWZpZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wdXRlZE5hbWVTdHJpbmcoeyBwb3M6IGFyZy5wb3MsIGVuZDogYXJnLmVuZCB9KTtcblxuICAgICAgICBpZiAoYXJnLnRleHQgJiYgYXJnLmtpbmQgIT09IHRoaXMudG9rZW5UeXBlLk51bWVyaWNMaXRlcmFsKVxuICAgICAgICAgICAgcmV0dXJuIGFyZy50ZXh0O1xuXG4gICAgICAgIGlmIChhcmcua2luZCA9PT0gdGhpcy50b2tlblR5cGUuVHlwZUFzc2VydGlvbkV4cHJlc3Npb24pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRGbkFyZyhhcmcuZXhwcmVzc2lvbik7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZ2V0Rm5DYWxsICh0b2tlbikge1xuICAgICAgICBpZiAodGhpcy5pc0FwaUZuKHRva2VuLmV4cHJlc3Npb24udGV4dCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRGbkRhdGEodG9rZW4uZXhwcmVzc2lvbi50ZXh0LCB0aGlzLmZvcm1hdEZuQXJnKHRva2VuLmFyZ3VtZW50c1swXSksIHRva2VuKTtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBnZXRUYWdnZWRUZW1wbGF0ZUV4cCAodG9rZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBcGlGbih0b2tlbi50YWcudGV4dCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRGbkRhdGEodG9rZW4udGFnLnRleHQsIHRoaXMuZm9ybWF0Rm5BcmcodG9rZW4pLCB0b2tlbik7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgYW5hbHl6ZUZuQ2FsbCAodG9rZW4pIHtcbiAgICAgICAgY29uc3QgdG9rZW5UeXBlID0gdGhpcy50b2tlblR5cGU7XG5cbiAgICAgICAgaWYgKHRva2VuLmtpbmQgPT09IHRva2VuVHlwZS5Qcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmFseXplTWVtYmVyRXhwKHRva2VuKTtcblxuICAgICAgICBpZiAodG9rZW4ua2luZCA9PT0gdG9rZW5UeXBlLkNhbGxFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBjb25zdCBleHBLaW5kID0gdG9rZW4uZXhwcmVzc2lvbi5raW5kO1xuXG4gICAgICAgICAgICBpZiAoZXhwS2luZCA9PT0gdG9rZW5UeXBlLlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbiB8fCBleHBLaW5kID09PSB0b2tlblR5cGUuQ2FsbEV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5hbHl6ZU1lbWJlckV4cCh0b2tlbik7XG5cbiAgICAgICAgICAgIGlmIChleHBLaW5kID09PSB0b2tlblR5cGUuUGFyZW50aGVzaXplZEV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5hbHl6ZUZuQ2FsbCh0b2tlbi5leHByZXNzaW9uLmV4cHJlc3Npb24pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGbkNhbGwodG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuLmtpbmQgPT09IHRva2VuVHlwZS5GdW5jdGlvbkV4cHJlc3Npb24gfHwgdG9rZW4ua2luZCA9PT0gdG9rZW5UeXBlLkFycm93RnVuY3Rpb24pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xsZWN0VGVzdENhZmVDYWxscyh0aGlzLmdldEZ1bmN0aW9uQm9keSh0b2tlbikpO1xuXG4gICAgICAgIGlmICh0b2tlbi5raW5kID09PSB0b2tlblR5cGUuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4udGFnLmtpbmQgPT09IHRva2VuVHlwZS5Qcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24gfHwgdG9rZW4udGFnLmtpbmQgPT09IHRva2VuVHlwZS5DYWxsRXhwcmVzc2lvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hbmFseXplTWVtYmVyRXhwKHRva2VuKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGFnZ2VkVGVtcGxhdGVFeHAodG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcGFyc2UgKGNvZGUpIHtcbiAgICAgICAgLy9OT1RFOiBUeXBlU2NyaXB0IGNhbGN1bGF0ZXMgc3RhcnQgcG9zaXRpb24gb2YgYSB0b2tlbiBpbmNvcnJlY3RseVxuICAgICAgICAvL0l0IGRvZXNuJ3QgY29uc2lkZXIgc3BhY2VzIGFuZCBjb21tZW50cyBiZXR3ZWVuIHRoZSBsYXN0IHRva2VuIGFuZCB0aGUgY3VycmVudCB0b2tlbi5cbiAgICAgICAgLy9TbyB3ZSByZXBsYWNlIGNvbW1lbnRzIHdpdGggc3BhY2Ugc3ltYm9scyB0byBjYWxjdWxhdGUgZml4ZWQgcG9zaXRpb24uXG4gICAgICAgIC8vV2UganVzdCBpbmNyZW1lbnQgcG9zaXRpb24gdW50aWwgd2UgbWVldCBub24gd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG4gICAgICAgIHRoaXMuY29kZUFyciAgICAgICAgICAgICA9IGNvZGUuc3BsaXQoJ1xcbicpO1xuICAgICAgICB0aGlzLmNvZGVXaXRob3V0Q29tbWVudHMgPSByZXBsYWNlQ29tbWVudHMoY29kZSk7XG5cbiAgICAgICAgY29uc3Qgc291cmNlRmlsZSA9IHRzLmNyZWF0ZVNvdXJjZUZpbGUoJycsIGNvZGUsIFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLl9nZXRUeXBlc2NyaXB0T3B0aW9ucygpLCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5hbmFseXplKHNvdXJjZUZpbGUuc3RhdGVtZW50cyk7XG4gICAgfVxufVxuXG5jb25zdCBwYXJzZXIgPSBuZXcgVHlwZVNjcmlwdFRlc3RGaWxlUGFyc2VyKCk7XG5cbmV4cG9ydCBjb25zdCBnZXRUeXBlU2NyaXB0VGVzdExpc3QgICAgICAgICA9IHBhcnNlci5nZXRUZXN0TGlzdC5iaW5kKHBhcnNlcik7XG5leHBvcnQgY29uc3QgZ2V0VHlwZVNjcmlwdFRlc3RMaXN0RnJvbUNvZGUgPSBwYXJzZXIuZ2V0VGVzdExpc3RGcm9tQ29kZS5iaW5kKHBhcnNlcik7XG4iXX0=
