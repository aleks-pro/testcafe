'use strict';

exports.__esModule = true;
exports.getCallsiteForMethod = getCallsiteForMethod;
exports.getCallsiteForError = getCallsiteForError;

var _callsiteRecord = require('callsite-record');

var _callsiteRecord2 = _interopRequireDefault(_callsiteRecord);

var _stackCleaningHook = require('./stack-cleaning-hook');

var _stackCleaningHook2 = _interopRequireDefault(_stackCleaningHook);

var _sourceMapSupport = require('source-map-support');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const STACK_TRACE_LIMIT = 2000;

function getCallsite(options) {
    const originalStackCleaningEnabled = _stackCleaningHook2.default.enabled;
    const originalStackTraceLimit = Error.stackTraceLimit;

    _stackCleaningHook2.default.enabled = false;
    Error.stackTraceLimit = STACK_TRACE_LIMIT;

    const callsiteRecord = (0, _callsiteRecord2.default)(options);

    Error.stackTraceLimit = originalStackTraceLimit;
    _stackCleaningHook2.default.enabled = originalStackCleaningEnabled;

    return callsiteRecord;
}

function getCallsiteForMethod(methodName, typeName) {
    return getCallsite({ byFunctionName: methodName, typeName, processFrameFn: _sourceMapSupport.wrapCallSite });
}

function getCallsiteForError(error, isCallsiteFrame) {
    // NOTE: "source-map-support" process this kind of error automatically, cause
    // in this case there is an appeal to "err.stack" inside "callsite-record" which
    // provokes wrapping of frames, so there is no need to specify "processFrameFn".
    return getCallsite({ forError: error, isCallsiteFrame });
}
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lcnJvcnMvZ2V0LWNhbGxzaXRlLmpzIl0sIm5hbWVzIjpbImdldENhbGxzaXRlRm9yTWV0aG9kIiwiZ2V0Q2FsbHNpdGVGb3JFcnJvciIsIlNUQUNLX1RSQUNFX0xJTUlUIiwiZ2V0Q2FsbHNpdGUiLCJvcHRpb25zIiwib3JpZ2luYWxTdGFja0NsZWFuaW5nRW5hYmxlZCIsImVuYWJsZWQiLCJvcmlnaW5hbFN0YWNrVHJhY2VMaW1pdCIsIkVycm9yIiwic3RhY2tUcmFjZUxpbWl0IiwiY2FsbHNpdGVSZWNvcmQiLCJtZXRob2ROYW1lIiwidHlwZU5hbWUiLCJieUZ1bmN0aW9uTmFtZSIsInByb2Nlc3NGcmFtZUZuIiwiZXJyb3IiLCJpc0NhbGxzaXRlRnJhbWUiLCJmb3JFcnJvciJdLCJtYXBwaW5ncyI6Ijs7O1FBcUJnQkEsb0IsR0FBQUEsb0I7UUFJQUMsbUIsR0FBQUEsbUI7O0FBekJoQjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQSxNQUFNQyxvQkFBb0IsSUFBMUI7O0FBRUEsU0FBU0MsV0FBVCxDQUFzQkMsT0FBdEIsRUFBK0I7QUFDM0IsVUFBTUMsK0JBQStCLDRCQUFrQkMsT0FBdkQ7QUFDQSxVQUFNQywwQkFBK0JDLE1BQU1DLGVBQTNDOztBQUVBLGdDQUFrQkgsT0FBbEIsR0FBNEIsS0FBNUI7QUFDQUUsVUFBTUMsZUFBTixHQUE0QlAsaUJBQTVCOztBQUVBLFVBQU1RLGlCQUFpQiw4QkFBcUJOLE9BQXJCLENBQXZCOztBQUVBSSxVQUFNQyxlQUFOLEdBQTRCRix1QkFBNUI7QUFDQSxnQ0FBa0JELE9BQWxCLEdBQTRCRCw0QkFBNUI7O0FBRUEsV0FBT0ssY0FBUDtBQUNIOztBQUVNLFNBQVNWLG9CQUFULENBQStCVyxVQUEvQixFQUEyQ0MsUUFBM0MsRUFBcUQ7QUFDeEQsV0FBT1QsWUFBWSxFQUFFVSxnQkFBZ0JGLFVBQWxCLEVBQThCQyxRQUE5QixFQUF3Q0UsOENBQXhDLEVBQVosQ0FBUDtBQUNIOztBQUVNLFNBQVNiLG1CQUFULENBQThCYyxLQUE5QixFQUFxQ0MsZUFBckMsRUFBc0Q7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsV0FBT2IsWUFBWSxFQUFFYyxVQUFVRixLQUFaLEVBQW1CQyxlQUFuQixFQUFaLENBQVA7QUFDSCIsImZpbGUiOiJlcnJvcnMvZ2V0LWNhbGxzaXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZUNhbGxzaXRlUmVjb3JkIGZyb20gJ2NhbGxzaXRlLXJlY29yZCc7XG5pbXBvcnQgc3RhY2tDbGVhbmluZ0hvb2sgZnJvbSAnLi9zdGFjay1jbGVhbmluZy1ob29rJztcbmltcG9ydCB7IHdyYXBDYWxsU2l0ZSB9IGZyb20gJ3NvdXJjZS1tYXAtc3VwcG9ydCc7XG5cbmNvbnN0IFNUQUNLX1RSQUNFX0xJTUlUID0gMjAwMDtcblxuZnVuY3Rpb24gZ2V0Q2FsbHNpdGUgKG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcmlnaW5hbFN0YWNrQ2xlYW5pbmdFbmFibGVkID0gc3RhY2tDbGVhbmluZ0hvb2suZW5hYmxlZDtcbiAgICBjb25zdCBvcmlnaW5hbFN0YWNrVHJhY2VMaW1pdCAgICAgID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuXG4gICAgc3RhY2tDbGVhbmluZ0hvb2suZW5hYmxlZCA9IGZhbHNlO1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCAgICAgPSBTVEFDS19UUkFDRV9MSU1JVDtcblxuICAgIGNvbnN0IGNhbGxzaXRlUmVjb3JkID0gY3JlYXRlQ2FsbHNpdGVSZWNvcmQob3B0aW9ucyk7XG5cbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgICAgID0gb3JpZ2luYWxTdGFja1RyYWNlTGltaXQ7XG4gICAgc3RhY2tDbGVhbmluZ0hvb2suZW5hYmxlZCA9IG9yaWdpbmFsU3RhY2tDbGVhbmluZ0VuYWJsZWQ7XG5cbiAgICByZXR1cm4gY2FsbHNpdGVSZWNvcmQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDYWxsc2l0ZUZvck1ldGhvZCAobWV0aG9kTmFtZSwgdHlwZU5hbWUpIHtcbiAgICByZXR1cm4gZ2V0Q2FsbHNpdGUoeyBieUZ1bmN0aW9uTmFtZTogbWV0aG9kTmFtZSwgdHlwZU5hbWUsIHByb2Nlc3NGcmFtZUZuOiB3cmFwQ2FsbFNpdGUgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDYWxsc2l0ZUZvckVycm9yIChlcnJvciwgaXNDYWxsc2l0ZUZyYW1lKSB7XG4gICAgLy8gTk9URTogXCJzb3VyY2UtbWFwLXN1cHBvcnRcIiBwcm9jZXNzIHRoaXMga2luZCBvZiBlcnJvciBhdXRvbWF0aWNhbGx5LCBjYXVzZVxuICAgIC8vIGluIHRoaXMgY2FzZSB0aGVyZSBpcyBhbiBhcHBlYWwgdG8gXCJlcnIuc3RhY2tcIiBpbnNpZGUgXCJjYWxsc2l0ZS1yZWNvcmRcIiB3aGljaFxuICAgIC8vIHByb3Zva2VzIHdyYXBwaW5nIG9mIGZyYW1lcywgc28gdGhlcmUgaXMgbm8gbmVlZCB0byBzcGVjaWZ5IFwicHJvY2Vzc0ZyYW1lRm5cIi5cbiAgICByZXR1cm4gZ2V0Q2FsbHNpdGUoeyBmb3JFcnJvcjogZXJyb3IsIGlzQ2FsbHNpdGVGcmFtZSB9KTtcbn1cbiJdfQ==
